import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'maintenance_schedule_model.dart';

class MaintenanceCalendarProvider with ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  List<MaintenanceSchedule> _maintenances = [];
  Map<DateTime, List<MaintenanceSchedule>> _eventsByDate = {};
  bool _isLoading = false;
  String? _error;
  
  // Filtros
  String _selectedTechnician = 'all';
  String _selectedClient = 'all';
  MaintenanceStatus? _selectedStatus;
  DateTime? _filterStartDate;
  DateTime? _filterEndDate;

  // Getters
  List<MaintenanceSchedule> get maintenances => _maintenances;
  Map<DateTime, List<MaintenanceSchedule>> get eventsByDate => _eventsByDate;
  bool get isLoading => _isLoading;
  String? get error => _error;
  String get selectedTechnician => _selectedTechnician;
  String get selectedClient => _selectedClient;
  MaintenanceStatus? get selectedStatus => _selectedStatus;
  DateTime? get filterStartDate => _filterStartDate;
  DateTime? get filterEndDate => _filterEndDate;

  // Método auxiliar para conversión segura de tipos numéricos
  static int? _safeIntFromDynamic(dynamic value) {
    if (value == null) return null;
    if (value is int) return value;
    if (value is double) return value.round();
    if (value is String) return int.tryParse(value);
    return null;
  }

  static double? _safeDoubleFromDynamic(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) return double.tryParse(value);
    return null;
  }

  // Método para validar y limpiar datos de mantenimiento
  Map<String, dynamic> _sanitizeMaintenanceData(Map<String, dynamic> data) {
    final sanitized = Map<String, dynamic>.from(data);

    // Validar campos obligatorios
    sanitized['equipmentId'] = data['equipmentId'] ?? '';
    sanitized['equipmentName'] = data['equipmentName'] ?? '';
    sanitized['clientId'] = data['clientId'] ?? '';
    sanitized['clientName'] = data['clientName'] ?? '';
    sanitized['createdBy'] = data['createdBy'] ?? '';
    sanitized['status'] = data['status'] ?? 'scheduled';
    sanitized['type'] = data['type'] ?? 'preventive';
    sanitized['frequency'] = data['frequency'] ?? 'monthly';

    // Manejar fechas
    if (data['scheduledDate'] == null) {
      sanitized['scheduledDate'] = Timestamp.fromDate(DateTime.now());
    }
    if (data['createdAt'] == null) {
      sanitized['createdAt'] = Timestamp.fromDate(DateTime.now());
    }
    if (data['updatedAt'] == null) {
      sanitized['updatedAt'] = Timestamp.fromDate(DateTime.now());
    }

    // Limpiar tipos numéricos
    sanitized['estimatedDurationMinutes'] = _safeIntFromDynamic(data['estimatedDurationMinutes']) ?? 60;
    sanitized['completionPercentage'] = _safeIntFromDynamic(data['completionPercentage']) ?? 0;
    sanitized['estimatedCost'] = _safeDoubleFromDynamic(data['estimatedCost']);
    sanitized['actualCost'] = _safeDoubleFromDynamic(data['actualCost']);

    // Validar arrays
    sanitized['tasks'] = data['tasks'] is List ? List<String>.from(data['tasks']) : <String>[];
    sanitized['photoUrls'] = data['photoUrls'] is List ? List<String>.from(data['photoUrls']) : <String>[];

    return sanitized;
  }

  // Métodos principales con manejo de errores mejorado
  Future<void> loadMaintenances({
    String? clientId,
    String? technicianId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      _isLoading = true;
      _error = null;
      notifyListeners();

      Query query = _firestore.collection('maintenanceSchedules');

      // Aplicar filtros
      if (clientId != null && clientId != 'all') {
        query = query.where('clientId', isEqualTo: clientId);
      }
      
      if (technicianId != null && technicianId != 'all') {
        query = query.where('technicianId', isEqualTo: technicianId);
      }

      if (startDate != null) {
        query = query.where('scheduledDate', isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
      }

      if (endDate != null) {
        query = query.where('scheduledDate', isLessThanOrEqualTo: Timestamp.fromDate(endDate));
      }

      // Ordenar por fecha programada
      query = query.orderBy('scheduledDate');

      final querySnapshot = await query.get();
      
      _maintenances = [];
      
      for (final doc in querySnapshot.docs) {
        try {
          final maintenance = MaintenanceSchedule.fromFirestore(doc);
          _maintenances.add(maintenance);
        } catch (e) {
          debugPrint('Error procesando documento ${doc.id}: $e');
          debugPrint('Datos problemáticos: ${doc.data()}');
          
          // Intentar reparar datos corruptos
          try {
            final data = doc.data() as Map<String, dynamic>;
            final cleanedData = _sanitizeMaintenanceData(data);
            await doc.reference.update(cleanedData);
            
            // Intentar crear el mantenimiento nuevamente con datos limpios
            final repairedMaintenance = MaintenanceSchedule.fromFirestore(
              doc.reference.get().then((updatedDoc) => updatedDoc)
            );
            // No agregamos aquí para evitar problemas de async
          } catch (repairError) {
            debugPrint('No se pudo reparar el documento ${doc.id}: $repairError');
          }
        }
      }

      _buildEventsMap();
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = 'Error al cargar mantenimientos: $e';
      _isLoading = false;
      debugPrint('Error completo en loadMaintenances: $e');
      notifyListeners();
    }
  }

  void _buildEventsMap() {
    _eventsByDate.clear();
    
    for (var maintenance in _maintenances) {
      try {
        final date = DateTime(
          maintenance.scheduledDate.year,
          maintenance.scheduledDate.month,
          maintenance.scheduledDate.day,
        );
        
        if (_eventsByDate[date] != null) {
          _eventsByDate[date]!.add(maintenance);
        } else {
          _eventsByDate[date] = [maintenance];
        }
      } catch (e) {
        debugPrint('Error procesando fecha para mantenimiento ${maintenance.id}: $e');
      }
    }
  }

  List<MaintenanceSchedule> getEventsForDay(DateTime day) {
    try {
      final normalizedDay = DateTime(day.year, day.month, day.day);
      return _eventsByDate[normalizedDay] ?? [];
    } catch (e) {
      debugPrint('Error obteniendo eventos del día: $e');
      return [];
    }
  }

  List<MaintenanceSchedule> getEventsForRange(DateTime start, DateTime end) {
    try {
      final events = <MaintenanceSchedule>[];
      for (var maintenance in _maintenances) {
        if (maintenance.scheduledDate.isAfter(start.subtract(const Duration(days: 1))) &&
            maintenance.scheduledDate.isBefore(end.add(const Duration(days: 1)))) {
          events.add(maintenance);
        }
      }
      return events;
    } catch (e) {
      debugPrint('Error obteniendo eventos del rango: $e');
      return [];
    }
  }

  // CRUD Operations con manejo de errores
  Future<String> addMaintenance(MaintenanceSchedule maintenance) async {
    try {
      _isLoading = true;
      notifyListeners();

      // Limpiar datos antes de guardar
      final cleanData = _sanitizeMaintenanceData(maintenance.toFirestore());

      final docRef = await _firestore.collection('maintenanceSchedules').add(cleanData);

      final newMaintenance = maintenance.copyWith(id: docRef.id);
      _maintenances.add(newMaintenance);
      _buildEventsMap();
      
      _isLoading = false;
      notifyListeners();
      
      return docRef.id;
    } catch (e) {
      _error = 'Error al agregar mantenimiento: $e';
      _isLoading = false;
      debugPrint('Error en addMaintenance: $e');
      notifyListeners();
      rethrow;
    }
  }

  Future<void> updateMaintenance(MaintenanceSchedule maintenance) async {
    try {
      _isLoading = true;
      notifyListeners();

      // Limpiar datos antes de actualizar
      final cleanData = _sanitizeMaintenanceData(maintenance.toFirestore());

      await _firestore
          .collection('maintenanceSchedules')
          .doc(maintenance.id)
          .update(cleanData);

      final index = _maintenances.indexWhere((m) => m.id == maintenance.id);
      if (index != -1) {
        _maintenances[index] = maintenance;
        _buildEventsMap();
      }

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = 'Error al actualizar mantenimiento: $e';
      _isLoading = false;
      debugPrint('Error en updateMaintenance: $e');
      notifyListeners();
      rethrow;
    }
  }

  Future<void> deleteMaintenance(String maintenanceId) async {
    try {
      _isLoading = true;
      notifyListeners();

      await _firestore
          .collection('maintenanceSchedules')
          .doc(maintenanceId)
          .delete();

      _maintenances.removeWhere((m) => m.id == maintenanceId);
      _buildEventsMap();

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = 'Error al eliminar mantenimiento: $e';
      _isLoading = false;
      debugPrint('Error en deleteMaintenance: $e');
      notifyListeners();
      rethrow;
    }
  }

  Future<void> updateMaintenanceStatus(
    String maintenanceId,
    MaintenanceStatus status, {
    DateTime? completedDate,
    String? completedBy,
    int? completionPercentage,
    Map<String, bool>? taskCompletion,
  }) async {
    try {
      final maintenance = _maintenances.firstWhere((m) => m.id == maintenanceId);
      
      final updatedMaintenance = maintenance.copyWith(
        status: status,
        completedDate: completedDate,
        completedBy: completedBy,
        completionPercentage: completionPercentage ?? maintenance.completionPercentage,
        taskCompletion: taskCompletion ?? maintenance.taskCompletion,
        updatedAt: DateTime.now(),
      );

      await updateMaintenance(updatedMaintenance);
    } catch (e) {
      debugPrint('Error en updateMaintenanceStatus: $e');
      rethrow;
    }
  }

  // Métodos de programación automática
  Future<void> scheduleRecurringMaintenance({
    required String equipmentId,
    required FrequencyType frequency,
    required DateTime startDate,
    required int durationMonths,
    required List<String> tasks,
    required int estimatedDurationMinutes,
    String? technicianId,
    String? supervisorId,
    double? estimatedCost,
  }) async {
    try {
      final equipment = await _getEquipmentById(equipmentId);
      if (equipment == null) {
        throw Exception('Equipo no encontrado');
      }

      final scheduleDates = _generateRecurringDates(frequency, startDate, durationMonths);
      
      for (final date in scheduleDates) {
        final maintenance = MaintenanceSchedule(
          id: '', // Se generará en Firebase
          equipmentId: equipmentId,
          equipmentName: equipment['name'] ?? '',
          clientId: equipment['clientId'] ?? '',
          clientName: equipment['clientName'] ?? '',
          technicianId: technicianId,
          technicianName: technicianId != null ? await _getTechnicianName(technicianId) : null,
          supervisorId: supervisorId,
          supervisorName: supervisorId != null ? await _getSupervisorName(supervisorId) : null,
          scheduledDate: date,
          status: MaintenanceStatus.scheduled,
          type: MaintenanceType.preventive,
          frequency: frequency,
          tasks: tasks,
          estimatedDurationMinutes: estimatedDurationMinutes,
          estimatedCost: estimatedCost,
          location: equipment['location'],
          photoUrls: [],
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          createdBy: 'system', // O el ID del usuario actual
        );

        await addMaintenance(maintenance);
      }
    } catch (e) {
      debugPrint('Error en scheduleRecurringMaintenance: $e');
      rethrow;
    }
  }

  List<DateTime> _generateRecurringDates(
    FrequencyType frequency,
    DateTime startDate,
    int durationMonths,
  ) {
    final dates = <DateTime>[];
    var currentDate = startDate;
    final endDate = startDate.add(Duration(days: durationMonths * 30));

    while (currentDate.isBefore(endDate)) {
      dates.add(currentDate);
      
      switch (frequency) {
        case FrequencyType.weekly:
          currentDate = currentDate.add(const Duration(days: 7));
          break;
        case FrequencyType.biweekly:
          currentDate = currentDate.add(const Duration(days: 14));
          break;
        case FrequencyType.monthly:
          currentDate = DateTime(
            currentDate.year,
            currentDate.month + 1,
            currentDate.day,
          );
          break;
        case FrequencyType.quarterly:
          currentDate = DateTime(
            currentDate.year,
            currentDate.month + 3,
            currentDate.day,
          );
          break;
        case FrequencyType.biannual:
          currentDate = DateTime(
            currentDate.year,
            currentDate.month + 6,
            currentDate.day,
          );
          break;
        case FrequencyType.annual:
          currentDate = DateTime(
            currentDate.year + 1,
            currentDate.month,
            currentDate.day,
          );
          break;
        case FrequencyType.custom:
          // Implementar lógica personalizada
          currentDate = currentDate.add(const Duration(days: 30));
          break;
      }
    }

    return dates;
  }

  // Métodos auxiliares con manejo de errores
  Future<Map<String, dynamic>?> _getEquipmentById(String equipmentId) async {
    try {
      final doc = await _firestore.collection('equipments').doc(equipmentId).get();
      return doc.exists ? doc.data() : null;
    } catch (e) {
      debugPrint('Error obteniendo equipo: $e');
      return null;
    }
  }

  Future<String?> _getTechnicianName(String technicianId) async {
    try {
      final doc = await _firestore.collection('users').doc(technicianId).get();
      return doc.exists ? doc.data()?['name'] : null;
    } catch (e) {
      debugPrint('Error obteniendo nombre del técnico: $e');
      return null;
    }
  }

  Future<String?> _getSupervisorName(String supervisorId) async {
    try {
      final doc = await _firestore.collection('users').doc(supervisorId).get();
      return doc.exists ? doc.data()?['name'] : null;
    } catch (e) {
      debugPrint('Error obteniendo nombre del supervisor: $e');
      return null;
    }
  }

  // Métodos de filtrado
  void setTechnicianFilter(String technicianId) {
    _selectedTechnician = technicianId;
    _applyFilters();
  }

  void setClientFilter(String clientId) {
    _selectedClient = clientId;
    _applyFilters();
  }

  void setStatusFilter(MaintenanceStatus? status) {
    _selectedStatus = status;
    _applyFilters();
  }

  void setDateRangeFilter(DateTime? startDate, DateTime? endDate) {
    _filterStartDate = startDate;
    _filterEndDate = endDate;
    _applyFilters();
  }

  void clearFilters() {
    _selectedTechnician = 'all';
    _selectedClient = 'all';
    _selectedStatus = null;
    _filterStartDate = null;
    _filterEndDate = null;
    _applyFilters();
  }

  void _applyFilters() {
    loadMaintenances(
      clientId: _selectedClient,
      technicianId: _selectedTechnician,
      startDate: _filterStartDate,
      endDate: _filterEndDate,
    );
  }

  // Métodos de búsqueda y estadísticas con manejo de errores
  List<MaintenanceSchedule> searchMaintenances(String query) {
    try {
      if (query.isEmpty) return _maintenances;
      
      final lowerQuery = query.toLowerCase();
      return _maintenances.where((maintenance) {
        return maintenance.equipmentName.toLowerCase().contains(lowerQuery) ||
               maintenance.clientName.toLowerCase().contains(lowerQuery) ||
               (maintenance.technicianName?.toLowerCase().contains(lowerQuery) ?? false) ||
               (maintenance.location?.toLowerCase().contains(lowerQuery) ?? false);
      }).toList();
    } catch (e) {
      debugPrint('Error en búsqueda: $e');
      return [];
    }
  }

  Map<MaintenanceStatus, int> getMaintenanceStats() {
    try {
      final stats = <MaintenanceStatus, int>{};
      
      for (final status in MaintenanceStatus.values) {
        stats[status] = _maintenances.where((m) => m.status == status).length;
      }
      
      return stats;
    } catch (e) {
      debugPrint('Error obteniendo estadísticas: $e');
      return {};
    }
  }

  List<MaintenanceSchedule> getOverdueMaintenances() {
    try {
      return _maintenances.where((m) => m.isOverdue).toList();
    } catch (e) {
      debugPrint('Error obteniendo mantenimientos vencidos: $e');
      return [];
    }
  }

  List<MaintenanceSchedule> getUpcomingMaintenances(int days) {
    try {
      final now = DateTime.now();
      final futureDate = now.add(Duration(days: days));
      
      return _maintenances.where((m) {
        return m.scheduledDate.isAfter(now) &&
               m.scheduledDate.isBefore(futureDate) &&
               m.status == MaintenanceStatus.scheduled;
      }).toList();
    } catch (e) {
      debugPrint('Error obteniendo próximos mantenimientos: $e');
      return [];
    }
  }

  double getTotalEstimatedCost() {
    try {
      return _maintenances
          .where((m) => m.estimatedCost != null)
          .fold(0.0, (sum, m) => sum + (m.estimatedCost ?? 0.0));
    } catch (e) {
      debugPrint('Error calculando costo estimado total: $e');
      return 0.0;
    }
  }

  double getTotalActualCost() {
    try {
      return _maintenances
          .where((m) => m.actualCost != null)
          .fold(0.0, (sum, m) => sum + (m.actualCost ?? 0.0));
    } catch (e) {
      debugPrint('Error calculando costo real total: $e');
      return 0.0;
    }
  }

  // Método para limpiar datos corruptos
  Future<void> cleanCorruptedData() async {
    try {
      _isLoading = true;
      notifyListeners();

      final snapshot = await _firestore.collection('maintenanceSchedules').get();
      
      for (final doc in snapshot.docs) {
        try {
          MaintenanceSchedule.fromFirestore(doc);
        } catch (e) {
          debugPrint('Documento corrupto encontrado: ${doc.id}');
          
          try {
            final data = doc.data() as Map<String, dynamic>;
            final cleanedData = _sanitizeMaintenanceData(data);
            await doc.reference.update(cleanedData);
            debugPrint('Documento reparado: ${doc.id}');
          } catch (repairError) {
            debugPrint('No se pudo reparar el documento ${doc.id}: $repairError');
          }
        }
      }

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = 'Error limpiando datos: $e';
      _isLoading = false;
      debugPrint('Error en cleanCorruptedData: $e');
      notifyListeners();
      rethrow;
    }
  }
}